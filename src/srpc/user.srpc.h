#pragma once
#include <stdio.h>
#include <string>
#include "srpc/rpc_define.h"
#include "user.pb.h"

namespace SignupService
{

/*
 * Server codes
 * Generated by SRPC
 */

class Service : public srpc::RPCService
{
public:
	// please implement these methods in server.cc

	virtual void Signup(ReqSignup *request, RespSignup *response,
					srpc::RPCContext *ctx) = 0;

public:
	Service();
};

/*
 * Client codes
 * Generated by SRPC
 */

using SignupDone = std::function<void (RespSignup *, srpc::RPCContext *)>;

class SRPCClient : public srpc::SRPCClient
{
public:
	void Signup(const ReqSignup *req, SignupDone done);
	void Signup(const ReqSignup *req, RespSignup *resp, srpc::RPCSyncContext *sync_ctx);
	WFFuture<std::pair<RespSignup, srpc::RPCSyncContext>> async_Signup(const ReqSignup *req);

public:
	SRPCClient(const char *host, unsigned short port);
	SRPCClient(const struct srpc::RPCClientParams *params);

public:
	srpc::SRPCClientTask *create_Signup_task(SignupDone done);
};

class SRPCHttpClient : public srpc::SRPCHttpClient
{
public:
	void Signup(const ReqSignup *req, SignupDone done);
	void Signup(const ReqSignup *req, RespSignup *resp, srpc::RPCSyncContext *sync_ctx);
	WFFuture<std::pair<RespSignup, srpc::RPCSyncContext>> async_Signup(const ReqSignup *req);

public:
	SRPCHttpClient(const char *host, unsigned short port);
	SRPCHttpClient(const struct srpc::RPCClientParams *params);

public:
	srpc::SRPCHttpClientTask *create_Signup_task(SignupDone done);
};

class BRPCClient : public srpc::BRPCClient
{
public:
	void Signup(const ReqSignup *req, SignupDone done);
	void Signup(const ReqSignup *req, RespSignup *resp, srpc::RPCSyncContext *sync_ctx);
	WFFuture<std::pair<RespSignup, srpc::RPCSyncContext>> async_Signup(const ReqSignup *req);

public:
	BRPCClient(const char *host, unsigned short port);
	BRPCClient(const struct srpc::RPCClientParams *params);

public:
	srpc::BRPCClientTask *create_Signup_task(SignupDone done);
};

class TRPCClient : public srpc::TRPCClient
{
public:
	void Signup(const ReqSignup *req, SignupDone done);
	void Signup(const ReqSignup *req, RespSignup *resp, srpc::RPCSyncContext *sync_ctx);
	WFFuture<std::pair<RespSignup, srpc::RPCSyncContext>> async_Signup(const ReqSignup *req);

public:
	TRPCClient(const char *host, unsigned short port);
	TRPCClient(const struct srpc::RPCClientParams *params);

public:
	srpc::TRPCClientTask *create_Signup_task(SignupDone done);
};

class TRPCHttpClient : public srpc::TRPCHttpClient
{
public:
	void Signup(const ReqSignup *req, SignupDone done);
	void Signup(const ReqSignup *req, RespSignup *resp, srpc::RPCSyncContext *sync_ctx);
	WFFuture<std::pair<RespSignup, srpc::RPCSyncContext>> async_Signup(const ReqSignup *req);

public:
	TRPCHttpClient(const char *host, unsigned short port);
	TRPCHttpClient(const struct srpc::RPCClientParams *params);

public:
	srpc::TRPCHttpClientTask *create_Signup_task(SignupDone done);
};

///// implements detials /////

inline Service::Service(): srpc::RPCService("SignupService")
{
	this->srpc::RPCService::add_method("Signup",
		[this](srpc::RPCWorker& worker) ->int {
			return ServiceRPCCallImpl(this, worker, &Service::Signup);
		});
}

inline SRPCClient::SRPCClient(const char *host, unsigned short port):
	srpc::SRPCClient("SignupService")
{
	struct srpc::RPCClientParams params = srpc::RPC_CLIENT_PARAMS_DEFAULT;
	
	params.host = host;
	params.port = port;
	this->srpc::SRPCClient::init(&params);
}

inline SRPCClient::SRPCClient(const struct srpc::RPCClientParams *params):
	srpc::SRPCClient("SignupService")
{
	const struct srpc::RPCClientParams *temp = params;
	struct srpc::RPCClientParams temp_params;
	
	this->srpc::SRPCClient::init(temp);
}

inline void SRPCClient::Signup(const ReqSignup *req, SignupDone done)
{
	auto *task = this->create_rpc_client_task("Signup", std::move(done));

	task->serialize_input(req);
	task->start();
}

inline void SRPCClient::Signup(const ReqSignup *req, RespSignup *resp, srpc::RPCSyncContext *sync_ctx)
{
	auto res = this->async_Signup(req).get();

	if (resp && res.second.success)
		*resp = std::move(res.first);

	if (sync_ctx)
		*sync_ctx = std::move(res.second);
}

inline WFFuture<std::pair<RespSignup, srpc::RPCSyncContext>> SRPCClient::async_Signup(const ReqSignup *req)
{
	using RESULT = std::pair<RespSignup, srpc::RPCSyncContext>;
	auto *pr = new WFPromise<RESULT>();
	auto fr = pr->get_future();
	auto *task = this->create_rpc_client_task<RespSignup>("Signup", srpc::RPCAsyncFutureCallback<RespSignup>);

	task->serialize_input(req);
	task->user_data = pr;
	task->start();
	return fr;
}

inline srpc::SRPCClientTask *SRPCClient::create_Signup_task(SignupDone done)
{
	return this->create_rpc_client_task("Signup", std::move(done));
}

inline SRPCHttpClient::SRPCHttpClient(const char *host, unsigned short port):
	srpc::SRPCHttpClient("SignupService")
{
	struct srpc::RPCClientParams params = srpc::RPC_CLIENT_PARAMS_DEFAULT;
	
	params.host = host;
	params.port = port;
	this->srpc::SRPCHttpClient::init(&params);
}

inline SRPCHttpClient::SRPCHttpClient(const struct srpc::RPCClientParams *params):
	srpc::SRPCHttpClient("SignupService")
{
	const struct srpc::RPCClientParams *temp = params;
	struct srpc::RPCClientParams temp_params;
	
	this->srpc::SRPCHttpClient::init(temp);
}

inline void SRPCHttpClient::Signup(const ReqSignup *req, SignupDone done)
{
	auto *task = this->create_rpc_client_task("Signup", std::move(done));

	task->serialize_input(req);
	task->start();
}

inline void SRPCHttpClient::Signup(const ReqSignup *req, RespSignup *resp, srpc::RPCSyncContext *sync_ctx)
{
	auto res = this->async_Signup(req).get();

	if (resp && res.second.success)
		*resp = std::move(res.first);

	if (sync_ctx)
		*sync_ctx = std::move(res.second);
}

inline WFFuture<std::pair<RespSignup, srpc::RPCSyncContext>> SRPCHttpClient::async_Signup(const ReqSignup *req)
{
	using RESULT = std::pair<RespSignup, srpc::RPCSyncContext>;
	auto *pr = new WFPromise<RESULT>();
	auto fr = pr->get_future();
	auto *task = this->create_rpc_client_task<RespSignup>("Signup", srpc::RPCAsyncFutureCallback<RespSignup>);

	task->serialize_input(req);
	task->user_data = pr;
	task->start();
	return fr;
}

inline srpc::SRPCHttpClientTask *SRPCHttpClient::create_Signup_task(SignupDone done)
{
	return this->create_rpc_client_task("Signup", std::move(done));
}

inline BRPCClient::BRPCClient(const char *host, unsigned short port):
	srpc::BRPCClient("SignupService")
{
	struct srpc::RPCClientParams params = srpc::RPC_CLIENT_PARAMS_DEFAULT;
	
	params.host = host;
	params.port = port;
	this->srpc::BRPCClient::init(&params);
}

inline BRPCClient::BRPCClient(const struct srpc::RPCClientParams *params):
	srpc::BRPCClient("SignupService")
{
	const struct srpc::RPCClientParams *temp = params;
	struct srpc::RPCClientParams temp_params;
	
	this->srpc::BRPCClient::init(temp);
}

inline void BRPCClient::Signup(const ReqSignup *req, SignupDone done)
{
	auto *task = this->create_rpc_client_task("Signup", std::move(done));

	task->serialize_input(req);
	task->start();
}

inline void BRPCClient::Signup(const ReqSignup *req, RespSignup *resp, srpc::RPCSyncContext *sync_ctx)
{
	auto res = this->async_Signup(req).get();

	if (resp && res.second.success)
		*resp = std::move(res.first);

	if (sync_ctx)
		*sync_ctx = std::move(res.second);
}

inline WFFuture<std::pair<RespSignup, srpc::RPCSyncContext>> BRPCClient::async_Signup(const ReqSignup *req)
{
	using RESULT = std::pair<RespSignup, srpc::RPCSyncContext>;
	auto *pr = new WFPromise<RESULT>();
	auto fr = pr->get_future();
	auto *task = this->create_rpc_client_task<RespSignup>("Signup", srpc::RPCAsyncFutureCallback<RespSignup>);

	task->serialize_input(req);
	task->user_data = pr;
	task->start();
	return fr;
}

inline srpc::BRPCClientTask *BRPCClient::create_Signup_task(SignupDone done)
{
	return this->create_rpc_client_task("Signup", std::move(done));
}

inline TRPCClient::TRPCClient(const char *host, unsigned short port):
	srpc::TRPCClient("SignupService")
{
	struct srpc::RPCClientParams params = srpc::RPC_CLIENT_PARAMS_DEFAULT;
	
	params.host = host;
	params.port = port;
	this->srpc::TRPCClient::init(&params);
}

inline TRPCClient::TRPCClient(const struct srpc::RPCClientParams *params):
	srpc::TRPCClient("SignupService")
{
	const struct srpc::RPCClientParams *temp = params;
	struct srpc::RPCClientParams temp_params;
	
	this->srpc::TRPCClient::init(temp);
}

inline void TRPCClient::Signup(const ReqSignup *req, SignupDone done)
{
	auto *task = this->create_rpc_client_task("/SignupService/Signup", std::move(done));

	if (!this->params.caller.empty())
		task->get_req()->set_caller_name(this->params.caller);
	task->serialize_input(req);
	task->start();
}

inline void TRPCClient::Signup(const ReqSignup *req, RespSignup *resp, srpc::RPCSyncContext *sync_ctx)
{
	auto res = this->async_Signup(req).get();

	if (resp && res.second.success)
		*resp = std::move(res.first);

	if (sync_ctx)
		*sync_ctx = std::move(res.second);
}

inline WFFuture<std::pair<RespSignup, srpc::RPCSyncContext>> TRPCClient::async_Signup(const ReqSignup *req)
{
	using RESULT = std::pair<RespSignup, srpc::RPCSyncContext>;
	auto *pr = new WFPromise<RESULT>();
	auto fr = pr->get_future();
	auto *task = this->create_rpc_client_task<RespSignup>("/SignupService/Signup", srpc::RPCAsyncFutureCallback<RespSignup>);

	if (!this->params.caller.empty())
		task->get_req()->set_caller_name(this->params.caller);
	task->serialize_input(req);
	task->user_data = pr;
	task->start();
	return fr;
}

inline srpc::TRPCClientTask *TRPCClient::create_Signup_task(SignupDone done)
{
	auto *task = this->create_rpc_client_task("/SignupService/Signup", std::move(done));

	if (!this->params.caller.empty())
		task->get_req()->set_caller_name(this->params.caller);

	return task;
}

inline TRPCHttpClient::TRPCHttpClient(const char *host, unsigned short port):
	srpc::TRPCHttpClient("SignupService")
{
	struct srpc::RPCClientParams params = srpc::RPC_CLIENT_PARAMS_DEFAULT;
	
	params.host = host;
	params.port = port;
	this->srpc::TRPCHttpClient::init(&params);
}

inline TRPCHttpClient::TRPCHttpClient(const struct srpc::RPCClientParams *params):
	srpc::TRPCHttpClient("SignupService")
{
	const struct srpc::RPCClientParams *temp = params;
	struct srpc::RPCClientParams temp_params;
	
	this->srpc::TRPCHttpClient::init(temp);
}

inline void TRPCHttpClient::Signup(const ReqSignup *req, SignupDone done)
{
	auto *task = this->create_rpc_client_task("Signup", std::move(done));

	if (!this->params.caller.empty())
		task->get_req()->set_caller_name(this->params.caller);
	task->serialize_input(req);
	task->start();
}

inline void TRPCHttpClient::Signup(const ReqSignup *req, RespSignup *resp, srpc::RPCSyncContext *sync_ctx)
{
	auto res = this->async_Signup(req).get();

	if (resp && res.second.success)
		*resp = std::move(res.first);

	if (sync_ctx)
		*sync_ctx = std::move(res.second);
}

inline WFFuture<std::pair<RespSignup, srpc::RPCSyncContext>> TRPCHttpClient::async_Signup(const ReqSignup *req)
{
	using RESULT = std::pair<RespSignup, srpc::RPCSyncContext>;
	auto *pr = new WFPromise<RESULT>();
	auto fr = pr->get_future();
	auto *task = this->create_rpc_client_task<RespSignup>("Signup", srpc::RPCAsyncFutureCallback<RespSignup>);

	if (!this->params.caller.empty())
		task->get_req()->set_caller_name(this->params.caller);
	task->serialize_input(req);
	task->user_data = pr;
	task->start();
	return fr;
}

inline srpc::TRPCHttpClientTask *TRPCHttpClient::create_Signup_task(SignupDone done)
{
	auto *task = this->create_rpc_client_task("Signup", std::move(done));

	if (!this->params.caller.empty())
		task->get_req()->set_caller_name(this->params.caller);

	return task;
}

} // end namespace SignupService


namespace SigninService
{

/*
 * Server codes
 * Generated by SRPC
 */

class Service : public srpc::RPCService
{
public:
	// please implement these methods in server.cc

	virtual void Signin(ReqSignin *request, RespSignin *response,
					srpc::RPCContext *ctx) = 0;

public:
	Service();
};

/*
 * Client codes
 * Generated by SRPC
 */

using SigninDone = std::function<void (RespSignin *, srpc::RPCContext *)>;

class SRPCClient : public srpc::SRPCClient
{
public:
	void Signin(const ReqSignin *req, SigninDone done);
	void Signin(const ReqSignin *req, RespSignin *resp, srpc::RPCSyncContext *sync_ctx);
	WFFuture<std::pair<RespSignin, srpc::RPCSyncContext>> async_Signin(const ReqSignin *req);

public:
	SRPCClient(const char *host, unsigned short port);
	SRPCClient(const struct srpc::RPCClientParams *params);

public:
	srpc::SRPCClientTask *create_Signin_task(SigninDone done);
};

class SRPCHttpClient : public srpc::SRPCHttpClient
{
public:
	void Signin(const ReqSignin *req, SigninDone done);
	void Signin(const ReqSignin *req, RespSignin *resp, srpc::RPCSyncContext *sync_ctx);
	WFFuture<std::pair<RespSignin, srpc::RPCSyncContext>> async_Signin(const ReqSignin *req);

public:
	SRPCHttpClient(const char *host, unsigned short port);
	SRPCHttpClient(const struct srpc::RPCClientParams *params);

public:
	srpc::SRPCHttpClientTask *create_Signin_task(SigninDone done);
};

class BRPCClient : public srpc::BRPCClient
{
public:
	void Signin(const ReqSignin *req, SigninDone done);
	void Signin(const ReqSignin *req, RespSignin *resp, srpc::RPCSyncContext *sync_ctx);
	WFFuture<std::pair<RespSignin, srpc::RPCSyncContext>> async_Signin(const ReqSignin *req);

public:
	BRPCClient(const char *host, unsigned short port);
	BRPCClient(const struct srpc::RPCClientParams *params);

public:
	srpc::BRPCClientTask *create_Signin_task(SigninDone done);
};

class TRPCClient : public srpc::TRPCClient
{
public:
	void Signin(const ReqSignin *req, SigninDone done);
	void Signin(const ReqSignin *req, RespSignin *resp, srpc::RPCSyncContext *sync_ctx);
	WFFuture<std::pair<RespSignin, srpc::RPCSyncContext>> async_Signin(const ReqSignin *req);

public:
	TRPCClient(const char *host, unsigned short port);
	TRPCClient(const struct srpc::RPCClientParams *params);

public:
	srpc::TRPCClientTask *create_Signin_task(SigninDone done);
};

class TRPCHttpClient : public srpc::TRPCHttpClient
{
public:
	void Signin(const ReqSignin *req, SigninDone done);
	void Signin(const ReqSignin *req, RespSignin *resp, srpc::RPCSyncContext *sync_ctx);
	WFFuture<std::pair<RespSignin, srpc::RPCSyncContext>> async_Signin(const ReqSignin *req);

public:
	TRPCHttpClient(const char *host, unsigned short port);
	TRPCHttpClient(const struct srpc::RPCClientParams *params);

public:
	srpc::TRPCHttpClientTask *create_Signin_task(SigninDone done);
};

///// implements detials /////

inline Service::Service(): srpc::RPCService("SigninService")
{
	this->srpc::RPCService::add_method("Signin",
		[this](srpc::RPCWorker& worker) ->int {
			return ServiceRPCCallImpl(this, worker, &Service::Signin);
		});
}

inline SRPCClient::SRPCClient(const char *host, unsigned short port):
	srpc::SRPCClient("SigninService")
{
	struct srpc::RPCClientParams params = srpc::RPC_CLIENT_PARAMS_DEFAULT;
	
	params.host = host;
	params.port = port;
	this->srpc::SRPCClient::init(&params);
}

inline SRPCClient::SRPCClient(const struct srpc::RPCClientParams *params):
	srpc::SRPCClient("SigninService")
{
	const struct srpc::RPCClientParams *temp = params;
	struct srpc::RPCClientParams temp_params;
	
	this->srpc::SRPCClient::init(temp);
}

inline void SRPCClient::Signin(const ReqSignin *req, SigninDone done)
{
	auto *task = this->create_rpc_client_task("Signin", std::move(done));

	task->serialize_input(req);
	task->start();
}

inline void SRPCClient::Signin(const ReqSignin *req, RespSignin *resp, srpc::RPCSyncContext *sync_ctx)
{
	auto res = this->async_Signin(req).get();

	if (resp && res.second.success)
		*resp = std::move(res.first);

	if (sync_ctx)
		*sync_ctx = std::move(res.second);
}

inline WFFuture<std::pair<RespSignin, srpc::RPCSyncContext>> SRPCClient::async_Signin(const ReqSignin *req)
{
	using RESULT = std::pair<RespSignin, srpc::RPCSyncContext>;
	auto *pr = new WFPromise<RESULT>();
	auto fr = pr->get_future();
	auto *task = this->create_rpc_client_task<RespSignin>("Signin", srpc::RPCAsyncFutureCallback<RespSignin>);

	task->serialize_input(req);
	task->user_data = pr;
	task->start();
	return fr;
}

inline srpc::SRPCClientTask *SRPCClient::create_Signin_task(SigninDone done)
{
	return this->create_rpc_client_task("Signin", std::move(done));
}

inline SRPCHttpClient::SRPCHttpClient(const char *host, unsigned short port):
	srpc::SRPCHttpClient("SigninService")
{
	struct srpc::RPCClientParams params = srpc::RPC_CLIENT_PARAMS_DEFAULT;
	
	params.host = host;
	params.port = port;
	this->srpc::SRPCHttpClient::init(&params);
}

inline SRPCHttpClient::SRPCHttpClient(const struct srpc::RPCClientParams *params):
	srpc::SRPCHttpClient("SigninService")
{
	const struct srpc::RPCClientParams *temp = params;
	struct srpc::RPCClientParams temp_params;
	
	this->srpc::SRPCHttpClient::init(temp);
}

inline void SRPCHttpClient::Signin(const ReqSignin *req, SigninDone done)
{
	auto *task = this->create_rpc_client_task("Signin", std::move(done));

	task->serialize_input(req);
	task->start();
}

inline void SRPCHttpClient::Signin(const ReqSignin *req, RespSignin *resp, srpc::RPCSyncContext *sync_ctx)
{
	auto res = this->async_Signin(req).get();

	if (resp && res.second.success)
		*resp = std::move(res.first);

	if (sync_ctx)
		*sync_ctx = std::move(res.second);
}

inline WFFuture<std::pair<RespSignin, srpc::RPCSyncContext>> SRPCHttpClient::async_Signin(const ReqSignin *req)
{
	using RESULT = std::pair<RespSignin, srpc::RPCSyncContext>;
	auto *pr = new WFPromise<RESULT>();
	auto fr = pr->get_future();
	auto *task = this->create_rpc_client_task<RespSignin>("Signin", srpc::RPCAsyncFutureCallback<RespSignin>);

	task->serialize_input(req);
	task->user_data = pr;
	task->start();
	return fr;
}

inline srpc::SRPCHttpClientTask *SRPCHttpClient::create_Signin_task(SigninDone done)
{
	return this->create_rpc_client_task("Signin", std::move(done));
}

inline BRPCClient::BRPCClient(const char *host, unsigned short port):
	srpc::BRPCClient("SigninService")
{
	struct srpc::RPCClientParams params = srpc::RPC_CLIENT_PARAMS_DEFAULT;
	
	params.host = host;
	params.port = port;
	this->srpc::BRPCClient::init(&params);
}

inline BRPCClient::BRPCClient(const struct srpc::RPCClientParams *params):
	srpc::BRPCClient("SigninService")
{
	const struct srpc::RPCClientParams *temp = params;
	struct srpc::RPCClientParams temp_params;
	
	this->srpc::BRPCClient::init(temp);
}

inline void BRPCClient::Signin(const ReqSignin *req, SigninDone done)
{
	auto *task = this->create_rpc_client_task("Signin", std::move(done));

	task->serialize_input(req);
	task->start();
}

inline void BRPCClient::Signin(const ReqSignin *req, RespSignin *resp, srpc::RPCSyncContext *sync_ctx)
{
	auto res = this->async_Signin(req).get();

	if (resp && res.second.success)
		*resp = std::move(res.first);

	if (sync_ctx)
		*sync_ctx = std::move(res.second);
}

inline WFFuture<std::pair<RespSignin, srpc::RPCSyncContext>> BRPCClient::async_Signin(const ReqSignin *req)
{
	using RESULT = std::pair<RespSignin, srpc::RPCSyncContext>;
	auto *pr = new WFPromise<RESULT>();
	auto fr = pr->get_future();
	auto *task = this->create_rpc_client_task<RespSignin>("Signin", srpc::RPCAsyncFutureCallback<RespSignin>);

	task->serialize_input(req);
	task->user_data = pr;
	task->start();
	return fr;
}

inline srpc::BRPCClientTask *BRPCClient::create_Signin_task(SigninDone done)
{
	return this->create_rpc_client_task("Signin", std::move(done));
}

inline TRPCClient::TRPCClient(const char *host, unsigned short port):
	srpc::TRPCClient("SigninService")
{
	struct srpc::RPCClientParams params = srpc::RPC_CLIENT_PARAMS_DEFAULT;
	
	params.host = host;
	params.port = port;
	this->srpc::TRPCClient::init(&params);
}

inline TRPCClient::TRPCClient(const struct srpc::RPCClientParams *params):
	srpc::TRPCClient("SigninService")
{
	const struct srpc::RPCClientParams *temp = params;
	struct srpc::RPCClientParams temp_params;
	
	this->srpc::TRPCClient::init(temp);
}

inline void TRPCClient::Signin(const ReqSignin *req, SigninDone done)
{
	auto *task = this->create_rpc_client_task("/SigninService/Signin", std::move(done));

	if (!this->params.caller.empty())
		task->get_req()->set_caller_name(this->params.caller);
	task->serialize_input(req);
	task->start();
}

inline void TRPCClient::Signin(const ReqSignin *req, RespSignin *resp, srpc::RPCSyncContext *sync_ctx)
{
	auto res = this->async_Signin(req).get();

	if (resp && res.second.success)
		*resp = std::move(res.first);

	if (sync_ctx)
		*sync_ctx = std::move(res.second);
}

inline WFFuture<std::pair<RespSignin, srpc::RPCSyncContext>> TRPCClient::async_Signin(const ReqSignin *req)
{
	using RESULT = std::pair<RespSignin, srpc::RPCSyncContext>;
	auto *pr = new WFPromise<RESULT>();
	auto fr = pr->get_future();
	auto *task = this->create_rpc_client_task<RespSignin>("/SigninService/Signin", srpc::RPCAsyncFutureCallback<RespSignin>);

	if (!this->params.caller.empty())
		task->get_req()->set_caller_name(this->params.caller);
	task->serialize_input(req);
	task->user_data = pr;
	task->start();
	return fr;
}

inline srpc::TRPCClientTask *TRPCClient::create_Signin_task(SigninDone done)
{
	auto *task = this->create_rpc_client_task("/SigninService/Signin", std::move(done));

	if (!this->params.caller.empty())
		task->get_req()->set_caller_name(this->params.caller);

	return task;
}

inline TRPCHttpClient::TRPCHttpClient(const char *host, unsigned short port):
	srpc::TRPCHttpClient("SigninService")
{
	struct srpc::RPCClientParams params = srpc::RPC_CLIENT_PARAMS_DEFAULT;
	
	params.host = host;
	params.port = port;
	this->srpc::TRPCHttpClient::init(&params);
}

inline TRPCHttpClient::TRPCHttpClient(const struct srpc::RPCClientParams *params):
	srpc::TRPCHttpClient("SigninService")
{
	const struct srpc::RPCClientParams *temp = params;
	struct srpc::RPCClientParams temp_params;
	
	this->srpc::TRPCHttpClient::init(temp);
}

inline void TRPCHttpClient::Signin(const ReqSignin *req, SigninDone done)
{
	auto *task = this->create_rpc_client_task("Signin", std::move(done));

	if (!this->params.caller.empty())
		task->get_req()->set_caller_name(this->params.caller);
	task->serialize_input(req);
	task->start();
}

inline void TRPCHttpClient::Signin(const ReqSignin *req, RespSignin *resp, srpc::RPCSyncContext *sync_ctx)
{
	auto res = this->async_Signin(req).get();

	if (resp && res.second.success)
		*resp = std::move(res.first);

	if (sync_ctx)
		*sync_ctx = std::move(res.second);
}

inline WFFuture<std::pair<RespSignin, srpc::RPCSyncContext>> TRPCHttpClient::async_Signin(const ReqSignin *req)
{
	using RESULT = std::pair<RespSignin, srpc::RPCSyncContext>;
	auto *pr = new WFPromise<RESULT>();
	auto fr = pr->get_future();
	auto *task = this->create_rpc_client_task<RespSignin>("Signin", srpc::RPCAsyncFutureCallback<RespSignin>);

	if (!this->params.caller.empty())
		task->get_req()->set_caller_name(this->params.caller);
	task->serialize_input(req);
	task->user_data = pr;
	task->start();
	return fr;
}

inline srpc::TRPCHttpClientTask *TRPCHttpClient::create_Signin_task(SigninDone done)
{
	auto *task = this->create_rpc_client_task("Signin", std::move(done));

	if (!this->params.caller.empty())
		task->get_req()->set_caller_name(this->params.caller);

	return task;
}

} // end namespace SigninService


namespace UserinfoService
{

/*
 * Server codes
 * Generated by SRPC
 */

class Service : public srpc::RPCService
{
public:
	// please implement these methods in server.cc

	virtual void Userinfo(ReqUserinfo *request, RespUserinfo *response,
					srpc::RPCContext *ctx) = 0;

public:
	Service();
};

/*
 * Client codes
 * Generated by SRPC
 */

using UserinfoDone = std::function<void (RespUserinfo *, srpc::RPCContext *)>;

class SRPCClient : public srpc::SRPCClient
{
public:
	void Userinfo(const ReqUserinfo *req, UserinfoDone done);
	void Userinfo(const ReqUserinfo *req, RespUserinfo *resp, srpc::RPCSyncContext *sync_ctx);
	WFFuture<std::pair<RespUserinfo, srpc::RPCSyncContext>> async_Userinfo(const ReqUserinfo *req);

public:
	SRPCClient(const char *host, unsigned short port);
	SRPCClient(const struct srpc::RPCClientParams *params);

public:
	srpc::SRPCClientTask *create_Userinfo_task(UserinfoDone done);
};

class SRPCHttpClient : public srpc::SRPCHttpClient
{
public:
	void Userinfo(const ReqUserinfo *req, UserinfoDone done);
	void Userinfo(const ReqUserinfo *req, RespUserinfo *resp, srpc::RPCSyncContext *sync_ctx);
	WFFuture<std::pair<RespUserinfo, srpc::RPCSyncContext>> async_Userinfo(const ReqUserinfo *req);

public:
	SRPCHttpClient(const char *host, unsigned short port);
	SRPCHttpClient(const struct srpc::RPCClientParams *params);

public:
	srpc::SRPCHttpClientTask *create_Userinfo_task(UserinfoDone done);
};

class BRPCClient : public srpc::BRPCClient
{
public:
	void Userinfo(const ReqUserinfo *req, UserinfoDone done);
	void Userinfo(const ReqUserinfo *req, RespUserinfo *resp, srpc::RPCSyncContext *sync_ctx);
	WFFuture<std::pair<RespUserinfo, srpc::RPCSyncContext>> async_Userinfo(const ReqUserinfo *req);

public:
	BRPCClient(const char *host, unsigned short port);
	BRPCClient(const struct srpc::RPCClientParams *params);

public:
	srpc::BRPCClientTask *create_Userinfo_task(UserinfoDone done);
};

class TRPCClient : public srpc::TRPCClient
{
public:
	void Userinfo(const ReqUserinfo *req, UserinfoDone done);
	void Userinfo(const ReqUserinfo *req, RespUserinfo *resp, srpc::RPCSyncContext *sync_ctx);
	WFFuture<std::pair<RespUserinfo, srpc::RPCSyncContext>> async_Userinfo(const ReqUserinfo *req);

public:
	TRPCClient(const char *host, unsigned short port);
	TRPCClient(const struct srpc::RPCClientParams *params);

public:
	srpc::TRPCClientTask *create_Userinfo_task(UserinfoDone done);
};

class TRPCHttpClient : public srpc::TRPCHttpClient
{
public:
	void Userinfo(const ReqUserinfo *req, UserinfoDone done);
	void Userinfo(const ReqUserinfo *req, RespUserinfo *resp, srpc::RPCSyncContext *sync_ctx);
	WFFuture<std::pair<RespUserinfo, srpc::RPCSyncContext>> async_Userinfo(const ReqUserinfo *req);

public:
	TRPCHttpClient(const char *host, unsigned short port);
	TRPCHttpClient(const struct srpc::RPCClientParams *params);

public:
	srpc::TRPCHttpClientTask *create_Userinfo_task(UserinfoDone done);
};

///// implements detials /////

inline Service::Service(): srpc::RPCService("UserinfoService")
{
	this->srpc::RPCService::add_method("Userinfo",
		[this](srpc::RPCWorker& worker) ->int {
			return ServiceRPCCallImpl(this, worker, &Service::Userinfo);
		});
}

inline SRPCClient::SRPCClient(const char *host, unsigned short port):
	srpc::SRPCClient("UserinfoService")
{
	struct srpc::RPCClientParams params = srpc::RPC_CLIENT_PARAMS_DEFAULT;
	
	params.host = host;
	params.port = port;
	this->srpc::SRPCClient::init(&params);
}

inline SRPCClient::SRPCClient(const struct srpc::RPCClientParams *params):
	srpc::SRPCClient("UserinfoService")
{
	const struct srpc::RPCClientParams *temp = params;
	struct srpc::RPCClientParams temp_params;
	
	this->srpc::SRPCClient::init(temp);
}

inline void SRPCClient::Userinfo(const ReqUserinfo *req, UserinfoDone done)
{
	auto *task = this->create_rpc_client_task("Userinfo", std::move(done));

	task->serialize_input(req);
	task->start();
}

inline void SRPCClient::Userinfo(const ReqUserinfo *req, RespUserinfo *resp, srpc::RPCSyncContext *sync_ctx)
{
	auto res = this->async_Userinfo(req).get();

	if (resp && res.second.success)
		*resp = std::move(res.first);

	if (sync_ctx)
		*sync_ctx = std::move(res.second);
}

inline WFFuture<std::pair<RespUserinfo, srpc::RPCSyncContext>> SRPCClient::async_Userinfo(const ReqUserinfo *req)
{
	using RESULT = std::pair<RespUserinfo, srpc::RPCSyncContext>;
	auto *pr = new WFPromise<RESULT>();
	auto fr = pr->get_future();
	auto *task = this->create_rpc_client_task<RespUserinfo>("Userinfo", srpc::RPCAsyncFutureCallback<RespUserinfo>);

	task->serialize_input(req);
	task->user_data = pr;
	task->start();
	return fr;
}

inline srpc::SRPCClientTask *SRPCClient::create_Userinfo_task(UserinfoDone done)
{
	return this->create_rpc_client_task("Userinfo", std::move(done));
}

inline SRPCHttpClient::SRPCHttpClient(const char *host, unsigned short port):
	srpc::SRPCHttpClient("UserinfoService")
{
	struct srpc::RPCClientParams params = srpc::RPC_CLIENT_PARAMS_DEFAULT;
	
	params.host = host;
	params.port = port;
	this->srpc::SRPCHttpClient::init(&params);
}

inline SRPCHttpClient::SRPCHttpClient(const struct srpc::RPCClientParams *params):
	srpc::SRPCHttpClient("UserinfoService")
{
	const struct srpc::RPCClientParams *temp = params;
	struct srpc::RPCClientParams temp_params;
	
	this->srpc::SRPCHttpClient::init(temp);
}

inline void SRPCHttpClient::Userinfo(const ReqUserinfo *req, UserinfoDone done)
{
	auto *task = this->create_rpc_client_task("Userinfo", std::move(done));

	task->serialize_input(req);
	task->start();
}

inline void SRPCHttpClient::Userinfo(const ReqUserinfo *req, RespUserinfo *resp, srpc::RPCSyncContext *sync_ctx)
{
	auto res = this->async_Userinfo(req).get();

	if (resp && res.second.success)
		*resp = std::move(res.first);

	if (sync_ctx)
		*sync_ctx = std::move(res.second);
}

inline WFFuture<std::pair<RespUserinfo, srpc::RPCSyncContext>> SRPCHttpClient::async_Userinfo(const ReqUserinfo *req)
{
	using RESULT = std::pair<RespUserinfo, srpc::RPCSyncContext>;
	auto *pr = new WFPromise<RESULT>();
	auto fr = pr->get_future();
	auto *task = this->create_rpc_client_task<RespUserinfo>("Userinfo", srpc::RPCAsyncFutureCallback<RespUserinfo>);

	task->serialize_input(req);
	task->user_data = pr;
	task->start();
	return fr;
}

inline srpc::SRPCHttpClientTask *SRPCHttpClient::create_Userinfo_task(UserinfoDone done)
{
	return this->create_rpc_client_task("Userinfo", std::move(done));
}

inline BRPCClient::BRPCClient(const char *host, unsigned short port):
	srpc::BRPCClient("UserinfoService")
{
	struct srpc::RPCClientParams params = srpc::RPC_CLIENT_PARAMS_DEFAULT;
	
	params.host = host;
	params.port = port;
	this->srpc::BRPCClient::init(&params);
}

inline BRPCClient::BRPCClient(const struct srpc::RPCClientParams *params):
	srpc::BRPCClient("UserinfoService")
{
	const struct srpc::RPCClientParams *temp = params;
	struct srpc::RPCClientParams temp_params;
	
	this->srpc::BRPCClient::init(temp);
}

inline void BRPCClient::Userinfo(const ReqUserinfo *req, UserinfoDone done)
{
	auto *task = this->create_rpc_client_task("Userinfo", std::move(done));

	task->serialize_input(req);
	task->start();
}

inline void BRPCClient::Userinfo(const ReqUserinfo *req, RespUserinfo *resp, srpc::RPCSyncContext *sync_ctx)
{
	auto res = this->async_Userinfo(req).get();

	if (resp && res.second.success)
		*resp = std::move(res.first);

	if (sync_ctx)
		*sync_ctx = std::move(res.second);
}

inline WFFuture<std::pair<RespUserinfo, srpc::RPCSyncContext>> BRPCClient::async_Userinfo(const ReqUserinfo *req)
{
	using RESULT = std::pair<RespUserinfo, srpc::RPCSyncContext>;
	auto *pr = new WFPromise<RESULT>();
	auto fr = pr->get_future();
	auto *task = this->create_rpc_client_task<RespUserinfo>("Userinfo", srpc::RPCAsyncFutureCallback<RespUserinfo>);

	task->serialize_input(req);
	task->user_data = pr;
	task->start();
	return fr;
}

inline srpc::BRPCClientTask *BRPCClient::create_Userinfo_task(UserinfoDone done)
{
	return this->create_rpc_client_task("Userinfo", std::move(done));
}

inline TRPCClient::TRPCClient(const char *host, unsigned short port):
	srpc::TRPCClient("UserinfoService")
{
	struct srpc::RPCClientParams params = srpc::RPC_CLIENT_PARAMS_DEFAULT;
	
	params.host = host;
	params.port = port;
	this->srpc::TRPCClient::init(&params);
}

inline TRPCClient::TRPCClient(const struct srpc::RPCClientParams *params):
	srpc::TRPCClient("UserinfoService")
{
	const struct srpc::RPCClientParams *temp = params;
	struct srpc::RPCClientParams temp_params;
	
	this->srpc::TRPCClient::init(temp);
}

inline void TRPCClient::Userinfo(const ReqUserinfo *req, UserinfoDone done)
{
	auto *task = this->create_rpc_client_task("/UserinfoService/Userinfo", std::move(done));

	if (!this->params.caller.empty())
		task->get_req()->set_caller_name(this->params.caller);
	task->serialize_input(req);
	task->start();
}

inline void TRPCClient::Userinfo(const ReqUserinfo *req, RespUserinfo *resp, srpc::RPCSyncContext *sync_ctx)
{
	auto res = this->async_Userinfo(req).get();

	if (resp && res.second.success)
		*resp = std::move(res.first);

	if (sync_ctx)
		*sync_ctx = std::move(res.second);
}

inline WFFuture<std::pair<RespUserinfo, srpc::RPCSyncContext>> TRPCClient::async_Userinfo(const ReqUserinfo *req)
{
	using RESULT = std::pair<RespUserinfo, srpc::RPCSyncContext>;
	auto *pr = new WFPromise<RESULT>();
	auto fr = pr->get_future();
	auto *task = this->create_rpc_client_task<RespUserinfo>("/UserinfoService/Userinfo", srpc::RPCAsyncFutureCallback<RespUserinfo>);

	if (!this->params.caller.empty())
		task->get_req()->set_caller_name(this->params.caller);
	task->serialize_input(req);
	task->user_data = pr;
	task->start();
	return fr;
}

inline srpc::TRPCClientTask *TRPCClient::create_Userinfo_task(UserinfoDone done)
{
	auto *task = this->create_rpc_client_task("/UserinfoService/Userinfo", std::move(done));

	if (!this->params.caller.empty())
		task->get_req()->set_caller_name(this->params.caller);

	return task;
}

inline TRPCHttpClient::TRPCHttpClient(const char *host, unsigned short port):
	srpc::TRPCHttpClient("UserinfoService")
{
	struct srpc::RPCClientParams params = srpc::RPC_CLIENT_PARAMS_DEFAULT;
	
	params.host = host;
	params.port = port;
	this->srpc::TRPCHttpClient::init(&params);
}

inline TRPCHttpClient::TRPCHttpClient(const struct srpc::RPCClientParams *params):
	srpc::TRPCHttpClient("UserinfoService")
{
	const struct srpc::RPCClientParams *temp = params;
	struct srpc::RPCClientParams temp_params;
	
	this->srpc::TRPCHttpClient::init(temp);
}

inline void TRPCHttpClient::Userinfo(const ReqUserinfo *req, UserinfoDone done)
{
	auto *task = this->create_rpc_client_task("Userinfo", std::move(done));

	if (!this->params.caller.empty())
		task->get_req()->set_caller_name(this->params.caller);
	task->serialize_input(req);
	task->start();
}

inline void TRPCHttpClient::Userinfo(const ReqUserinfo *req, RespUserinfo *resp, srpc::RPCSyncContext *sync_ctx)
{
	auto res = this->async_Userinfo(req).get();

	if (resp && res.second.success)
		*resp = std::move(res.first);

	if (sync_ctx)
		*sync_ctx = std::move(res.second);
}

inline WFFuture<std::pair<RespUserinfo, srpc::RPCSyncContext>> TRPCHttpClient::async_Userinfo(const ReqUserinfo *req)
{
	using RESULT = std::pair<RespUserinfo, srpc::RPCSyncContext>;
	auto *pr = new WFPromise<RESULT>();
	auto fr = pr->get_future();
	auto *task = this->create_rpc_client_task<RespUserinfo>("Userinfo", srpc::RPCAsyncFutureCallback<RespUserinfo>);

	if (!this->params.caller.empty())
		task->get_req()->set_caller_name(this->params.caller);
	task->serialize_input(req);
	task->user_data = pr;
	task->start();
	return fr;
}

inline srpc::TRPCHttpClientTask *TRPCHttpClient::create_Userinfo_task(UserinfoDone done)
{
	auto *task = this->create_rpc_client_task("Userinfo", std::move(done));

	if (!this->params.caller.empty())
		task->get_req()->set_caller_name(this->params.caller);

	return task;
}

} // end namespace UserinfoService

